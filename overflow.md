# Buffer Overflow (バッファオーバーフロー)

## Buffer(バッファ)とは

通常コンピュータプログラムは何らかの情報を格納するための領域をメモリ上に確保する。
その確保する情報とは数値や文字列であったり、文字情報を確保する際には、文字数に応じて連続したメモリ領域を確保する必要がある。

この同じ形式のデータ(ここでは文字)を複数個格納するために**メモリ上に確保する領域のことをバッファ領域**と読んでいる。

バッファの確保方法には**スタック**と**ヒープ**の2種類がある。
`スタックは、主に関数内で一時的に利用するデータを格納`するために利用される。
関数を呼び出す際は、関数呼び出し命令の次の命令が格納されているアドレス、つまり`子関数からの戻り先アドレス（以下、リターンアドレス）もスタックに格納`される。

`ヒープはプログラムによってメモリが必要になった際に、動的に確保`されたり、`プログラムの開始から終了まで参照される情報`を格納しておく領域。

## オーバーフローが起こる原因

なぜメモリ上に確保したバッファ領域はオーバーフローを起こすのか。
メモリは無限に存在するわけではないため、メモリ上に確保されるバッファ領域の大きさにも上限がある。

`バッファ領域の上限はプログラムが規定しているが、プログラムを実行するCPUはバッファ領域の上限を知らない`。CPUはプログラムに従って命令を実行するだけです。

情報をバッファ領域に格納する際、`格納する情報の大きさがバッファ領域の上限より小さい場合`は問題はないが、バッファ領域の上限を超えてしまう場合、`CPUはバッファ領域を超えて情報を格納`してしまい、バッファがオーバーフローしてしまう。

バッファオーバーフローが起こってしまうと、`メモリ上の不正な場所に情報を格納する`ことになってしまい、**プログラムが誤動作**することになってしまう。


### セキュリティーホールになるわけ

バッファオーバーフローがセキュリティホールになるワケをスタック上に確保されるバッファを例にする。

スタックには、CPUがそれまで実行していた関数の内部で使用しているバッファやリターンアドレスなどが保存される。
スタック上に存在するバッファでオーバーフローが発生すると、**リターンアドレスが格納されている領域も書き換えられてしまう**ことがある。`バッファオーバーフローによってリターンアドレスが書き換えられてしまう`と、親関数に戻る際に`正常なアドレスに戻れなくなる`。

この`バッファオーバーフローを利用して、リターンアドレスに「悪意のあるコードを格納しているメモリアドレス」をセットすることができる`としたらどうなるか。
親関数に戻る際に**本来の制御を横取りして、悪意のあるコードを実行**することができてしまう。

## バッファオーバーフローの流れ

下記の図の上側のようにスタック上のバッファ領域より大きい入力データのコピーが行われたとする。

![stack](https://image.itmedia.co.jp/ait/articles/0803/21/r20_5min_baf-01.gif "図")

上図のコピー後のスタックの状態のように、**バッファ領域より大きい入力データをサイズのチェックを行わずにコピー**を行ってしまうと、`バッファオーバーフローによりリターンアドレスが書き換え`られてしまう。

**プログラムが本来実行すべきリターンアドレスが書き換えられてしまう**ため、`プログラムが誤動作`してしまう。
命令アドレスが悪意のあるコードの存在するメモリアドレスで書き換えられた場合、CPUは悪意のあるコードを実行することになってしまう。

悪意のあるコードはどこにあるのか。答えは**オーバーフローさせるバッファに存在**する。
先ほどの図の下側のように入力するデータを作成することでバッファオーバーフローにより、悪意のあるコードを実行させることができる。
*悪意のあるコードのアドレスはスタック上であればある程度予測することが可能*であり、他にも**悪意のあるコードを実行させるためのテクニックがいくつか存在**する。

## 対策

どのようにすればバッファオーバーフローが発生しないプログラムを作成することができるのか。
C言語でプログラムを作成する際に注意することとしては以下のような点が挙げられる。

- バッファにデータを保存する際にデータサイズがバッファサイズを超えていないことを常に確認
- 標準関数の中で`strcpy`や`strcat`といったバッファのサイズをチェックしないでコピーする関数は使用しない

それでもバッファオーバーフローによるセキュリティホールが数多く見つかる。
プログラマが**間違った形式のデータが入力されることはないだろうという思い込み**や、プログラムの**実行速度を早くするため余計な処理を省く過程でチェック処理を省略**してしまうというようなことが考えられる。

個人で利用するために作成したプログラムならそれでも構わないが、広く公開し誰が使用するかは分からないプログラムの場合、`プログラマの想定していない使い方をされる可能性`が十分ある。
そのため、想定していないデータが入力されることは確実に存在する。

バッファオーバーフローを発生させないプログラムを作成するためには、`プログラマが入力データの形式を信用しない`ことが重要。
`プログラムをテストする際に、セキュリティホールとして利用できるかどうかという観点でテストを行うことも重要`になる。

# スタックオーバーフロー

## スタックとは

プログラムが実行されるときにはメモリが使用される。
このメモリは、64bitであれば16進数で0x0 ~ 0xffffffffffffffff まであり、プログラムのコードやプログラム中で使用した変数の値などが保存される。

スタックはメモリ上の領域であり、主にプログラムが関数を呼び出した時に関数内で宣言された値を格納するために使用される。

```
変数以外にも以下のものを格納する
- ローカル動的変数
- フレームポインタ
- 戻りアドレス(リターンアドレス)
```

保存するデータ集合体をスタックフレームという。

また、関数内で宣言してもmallocなどの動的確保された値はスタック領域には保存されず、ヒープ領域に保存される。

これは、関数を呼び出すごとに積み重ねられ、*関数が終了すると新しいものからポップ*される。

実際のメモリ内では、`スタックは高いアドレス (0xffffffffffffffff) の方から低いアドレスの方 (0x0) に伸びて`おり、`ヒープは低いアドレスから高いアドレスに伸びて`いる。

## IP(インストラクションポインタ)

スタックの詳しい説明には、IPという用語を理解する必要がある。

IP(インストラクションポインタ、またはプログラムカウンタ)は、次に実行する命令を格納するレジスタである。
レジスタが何かわからない人のために簡単に説明すると、レジスタとは*CPUそのものに内蔵されている記憶装置の一つ*である。(詳しい説明はここでは省く)

IPの動作をC言語を用いて説明する。

```c:ip.c
#include <stdio.h>

int test () {
    int n = 0;

    return 0;
}

int main () {
    int i = 0;

    test();

    return 0;
}
```

上記のコードで、プログラムが10行目を実行し終わった所だとする。(int i = 0)
そうすると、IPには次に実行する12行目の部分( test() )のアドレス格納される。

次に12行目が実行されるが、これは関数呼び出しである。
関数呼び出しでは、次に実行すべき命令のアドレス（ここでは、14行目の return 0）をスタックに保存してからその関数を実行する。

これは、関数が終了して戻ってきた際に次にどのアドレスにある命令を実行すればよいかを知るためである。

関数が呼び出されて4行目(test関数内のint n = 0)が実行され、次に6行目(test関数内のreturn 0)が実行される。
ここで、test関数は終了するのだが、関数呼び出しの時にスタックに保存したアドレス(14行目部分のアドレス)をIPに設定することで、main関数に戻り14行目を実行する。

IPはこのように、プログラムを実行するにおいて重要な役割を担っている。
オーバーフローなどの脆弱性がある場合、`攻撃者はこのIPの値を上書きすることでメモリ上の任意の場所にある命令を実行`することができる。

## フレームポインタ(FP)

フレームポインタ(FP)とは、スタックに**最後にpushされた関数のスタックフレームのrbpの値**を示す。(rbpとはベースポインタの意味で後述)

戻りアドレスには、遷移した関数の処理から、元に戻実行時点のプログラムカウンタ(IP,RIP)の値が入る。(IP : 次に実行する命令を格納するレジスタ)

## レジスタの種類

- SS : スタックセグメント
- RSP: スタックポインタ
- RBP: ベースポインタ
- RIP: プログラムカウンタ

RIPは前述したIP(インストラクションポインタ)のことでもある。
これは64bit(x64)の場合の呼び名なので、32bit(x86)の場合は`esp/ebp/eip`になる。

勘違いを防ぐためにもRSP/RBP/RIPなどはスタック(メモリ)内ではなく、レジスタなので**CPU内部**にある。

![rsp_rbp_rip.jpg](./rsp_rbp_rip.jpg)

### RSP スタックポインタ
スタックのトップのメモリアドレスが格納される。
push命令でデクリメント(-)され、pop命令でインクリメント(+)される。
(pushすると積み上がるので、0x00の方に進んでいくことから-マイナス方向に伸びる。)

現在処理中の関数の保存した**スタックの先頭を示すメモリアドレス**を保存するレジスタ。


### RBP

関数内において`スタック領域を扱う処理の基準となるメモリアドレス`です。
現在処理中の関数の保存した**スタックの末端を示すメモリアドレス**を保存するレジスタ

どの関数を処理しているかによって、レジスタrspに入るメモリアドレスが上の画像のように異なる。

---

関数Aが呼び出されるとスタックに関数Aのスタックフレームがpushされるため、その先頭アドレスがレジスタRSPに入る。

そして関数Aの処理が終わり、main関数に処理が戻るときに関数Aのスタックフレームがpopされるので、main関数のスタックフレームの先頭アドレスがレジスタRSPに入る。

## スタックの動作

スタックは、LIFO(後入れ先出し)方式の構造で、PUSHで値を格納し、POPで値を取り出す。
実際にプログラムでどう使用されるか簡単に説明する。
例えば、以下のようなプログラムを実行するとしよう。

```c:lifo.c
#include <stdio.h>

void B() {
  char buf[16];
  memcpy(buf, "BBBBBBBBCCCCCCCC", 16);
}

void A() {
  char buf[8];
  memcpy(buf, "AAAAAAAA", 8);

  B();
}

int main() {

  A();

  return 0;
}
```

上記は、main関数で関数Aを呼び出し、関数Aの中で関数Bを呼び出す単純なコードである。
ここで各呼び出しと関数終了時のスタックの状態を見るとおおよそ次のようになる。

![stack_trace](./20171011220319.jpg)

また、変数に格納される値は、高いアドレス(画像で言うと下)方向(0xffffffffffffffff)に格納されていくので、`もし関数Bで16を越える文字列が配列bufにコピー`すると*戻りアドレスが上書き*される。
（実際は、配列と戻りアドレスの間は少し空いているので、数バイト溢れただけでは戻りアドレスは上書きされない）

### スタック動作中のレジスタの動き

- 1 : 呼び出し元のRBP内のアドレスをスタックにpushする
- 2 : RSP内のアドレスをRBPレジスタに代入する

1で呼び出し元であるmain関数のアドレスをスタックにpushする。RBPレジスタに記録されているため、RBPレジスタからアドレスを取り出してスタックにpushする。

2の部分でRSPレジスタに記録されているアドレスを取り出して、RBPレジスタに代入することで、1でpushしたスタックの一番先頭のアドレスがRBPレジスタに入ることで基準になる。

関数の最後で次の処理を行う。

- 1 : RBP内のアドレスをRSPに代入する
- 2 : POPして、RBPレジスタに呼び出し元の値を入れる
- 3 : RETQ命令で呼び出し元に戻る

関数で処理が終了したら、1でRBPレジスタからアドレスを取り出して、RSPレジスタに代入します。

2の部分関数の最後の部分をPOPしたら、POPした箱からアドレスを取り出します。このアドレスは呼び出し元(main関数の一番下であるrbpの部分)を指しており、そのアドレスをRBPレジスタに格納します。

最後の3の部分でRETQ(return命令)で、main関数の一番下である呼び出し元のアドレスに戻ります。

### アセンブリの命令


**push**

- 1 : rspレジスタ内のアドレスの値をデクリメント(マイナス)する
- 2 : rspレジスタが指すメモリアドレスに値を書き込む

スタックはメモリアドレスの値の小さい方向(0x00)に伸びていく

**pop**

- 1 : rspレジスタが指すメモリアドレスから値を呼び出す
- 2 : rspレジスタ内のアドレスの値をインクリメント(プラス)する

**callq**

- 1 : rspレジスタ内のアドレスの値をデクリメント(マイナス)します。
- 2 : rspレジスタが指すメモリアドレスに**ripレジスタが指すアドレスの次のアドレス(上方向=0x00方向)**を書き込みます。
- 3 : ripレジスタに呼び出し先のアドレスを設定します。

**retq**

- 1 : rspレジスタ内のメモリアドレスから値を読み出してripレジスタに設定します。
- 2 : rspレジスタ内のアドレスの値をインクリメントします。

#### Function prologue

関数の先頭にある次の2命令はFunction prologueと呼ばれるお決まりの処理。
一番最初に行う命令。

**push %rbp**

呼び出し元のrbpをスタックにpushします。

呼び出し元であるアドレスがRBPレジスタ内にあるため、RBPレジスタ内の値(アドレス)をスタックにpushします。

**mov %rsp,%rbp**

rbpにrspをコピーします。
rspの値をrbpレジスタ内にコピーします。

関数内ではrbpを基準メモリアドレスとします。
これにより`rbp = rsp`になります。
(正確には後の`sub $0x20,%rsp`などの命令でrspレジスタ内の値を減算処理することでrspレジスタの値を更新している。)

![function_prologue](./function_prologue.png)

`caller addr`は呼び出し元のアドレスです。
呼び出し元のcallq命令の次の命令のアドレスです。
caller addrは呼び出し元のcallq命令でスタックにpushされます。

#### Function epilogue

関数の最後の2命令はFunction epilogueと呼ばれるお決まりの処理。
一番最初に行う命令。

**leaveq**

leaveq命令は次の命令と同じです。

```Bash
mov %rbp,%rsp
pop %rbp
```

rspレジスタにrbpレジスタ内の値をコピーする。
そして、pop命令で呼び出し元のアドレスをpopしてrbpレジスタに書き込みます。

つまり`Function prologueの逆処理`を行う。

leaveq命令後のスタック状態は次の通り

![function_epilogue.png](./function_epilogue.png)

**retq**

スタックから`caller addr`をpopしてripレジスタに代入します。
これにより呼び出し元に戻る。

## スタックオーバーフローを起こす

実際にスタックオーバーフローを起こすコードを書いてみる。

```c:stack_overflow.c
// vul.c
#include <stdio.h>
#include <string.h>

int main() {
  char buf[8];

  memcpy(buf, "AAAAAAAAAAAAAAAAAAAAAAAAA", 25);

  return 0;
}
```

上記のコードは8文字文の配列であるbufに25文字を入れたことにより、バッファが溢れ、その影響でプログラムが強制終了する。

```Bash
$ uname -a
Linux cmp 5.11.0-40-generic #44~20.04.2-Ubuntu SMP Tue Oct 26 18:07:44 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

$ gcc stack_overflow.c -o stack_overflow -fno-stack-protector
$ ./stack_overflow
Segmentation fault (core dumped)
```

gccのコンパイラのオプションに`-fno-stack-protector`を付けることで、スタック・オーバーフロー・セキュリティー・チェックが行われないようにする。

実際にコンパイルして実行してみると、想定通りにオーバーフローを起こして強制終了したことがわかる。

これは、関数に戻るためのアドレスが上書きされたことにより、よくわからないアドレスにある命令を実行しようとしてエラーが発生し、プログラムが強制終了したからである。

また、上記で出力された segmentation fault とは、アクセスが許可されていないアドレスにアクセスすると起こるエラーである。

## gdb (The GNU Debugger)でデバッグしてみる

下記のコードをgdbでデバッグしてみます。
main関数から足し算をするadd関数を呼び出します。


```c
#include <stdio.h>

int check_password(
    int a1,
    int a2,
    int a3,
    int a4,
    int a5,
    int a6,
    int a7,
    int a8,
    int a9,
    int a10
) {
    int c;
    c = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
    return c;
}

int main(int argc, char *argv[]) {
    int ret = add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    return ret;
}
```

gccでコンパイルする

- g : デバッグ情報あり
- O0 : 最適化なし


```Bash
$ gcc add.c -o add -g -O0

$ gdb ./add
```

```Bash
# ソースコード表示
(gdb) l

# アセンブルを表示
(gdb) disassemble

# レジスタの内容を表示
(gdb) info register rip rsp rbp
```

- https://gist.github.com/riywo/5480889
- https://qiita.com/tobira-code/items/75d3034aed8bb9828981
- https://codezine.jp/article/detail/420?p=3

## 対策技術

### SSP (Stack Smash Protection)

SSPとはコンパイラを用いて、スタックバッファオーバーフロー脆弱性を悪用した攻撃を防ぐ対策技術。
SSPはスタックフレーム内のebpレジスタとローカル変数の間に配置した`canary`と呼ばれる値の書き換えの有無によってスタックバッファオーバーフロー攻撃を検知する対策技術。

プログラムの実行中で、関数の呼び出し時に`スタックにcanaryを挿入`し、関数からリターンする直前に埋め込んだ`canaryの値が書き換えられていないかチェック`する。

canaryの値が書き換えられていない場合は、通常通り実行が完了するが、スタックバッファオーバーフロー攻撃によってバッファのサイズ以上の入力があり、canaryの値が書き換えられていた場合は実行を中止する。

実行を中止することによって同じスタックフレーム内のリターンアドレスや変数、ポインタなどが改竄されてしまうことを防ぐ。ただし、**canaryの値を正しく上書きすると攻撃が成功してしまう。**

SSPは、コンパイル時に`canaryを挿入する命令`と`canaryの値をチェックする命令`が、オリジナルのプログラムの**関数の前後**に挿入される。

![SSP.jpg](./SSP.jpg)

### データ実行防止機能

データ実行防止機能とは、CPUの機能を用いたスタックバッファオーバーフロー脆弱性を悪用した攻撃を防ぐ対策技術。

データ実行防止機能では、プログラムの実行時に用意される仮想メモリ空間を`「（プログラムが配置される）テキスト領域」`と`「（データのみ配置される）データ領域」`に**分離**する。

プログラムの実行時に、データ領域にあるコードを実行しようとすると、CPUがプログラムを停止させる。

データ実行防止機能はバッファオーバーフロー脆弱性を悪用してデータ領域に送り込んだ不正なコードを実行する攻撃に対して有効。
万が一リターンアドレスを書き換えられてしまったとしても、データ領域から不正なコードの実行を阻止することができる。

```
データ実行防止機能の実現には、CPUの機能が必要で、Intel CPUではNXbitと呼ばれる。
NXbitなどを用いたOSでのデータ実行防止機能を、WindowsOSではDEP、LinuxではPaXやExec Shield、OpenBSDではW^Xと呼ばれます。

※一部，CPUの機能を用いていないものもある。
```

![DEP.jpg](./DEP.jpg)

### アドレス空間のランダム化 (ASLR：Address Space Layer Randomization)

ASLRは、プログラムの実行開始時に決定される**データ領域やスタック領域、ヒープ領域などのアドレスを実行毎にランダムにする**ことで攻撃者によるアドレスを指定した攻撃を防ぐ対策技術。

データ領域やスタック領域、ヒープ領域などのアドレスが固定されている場合、攻撃者から重要なデータのアドレスを特定されやすくなる。
これらの領域のアドレスをランダムにすることで、特定のアドレスを狙った書き換えることが困難になる。
ASLRはOSの機能として実装されていて、Windows,Linux,iOSやAndroidなどに実装されている。

前述の領域に加えて、対象プログラムのテキスト領域のアドレスもランダム化することができる。
それを実現するのが、`PIE(Position-Independent Executable：位置独立実行形式)`と呼ばれる仕組みです。

![ASLR.jpg](./ASLR.jpg)

### Automatic Fortification

`Automatic Fortification`は、GCCのバージョン4.0から導入されているセキュリティ機構。
バッファオーバーフローを引き起こす要因の一つとして、プログラム中でstrcpy関数のように書き込み先のバッファのサイズを確認せずに処理をおこなってしまうライブラリ関数を利用していることが挙げられる。

Automatic Fortificationは脆弱性の原因となるような関数をコンパイル時に、別の安全性の高い同じ機能を持つ関数へと置換する。

![AF.jpg](./AF.jpg)

ret2esp

アドレス空間のランダム化機能であるASLR（Address Space Layout Randomization）機構

これらを回避するReturn Oriented Programmingなどの攻撃手法も登場
